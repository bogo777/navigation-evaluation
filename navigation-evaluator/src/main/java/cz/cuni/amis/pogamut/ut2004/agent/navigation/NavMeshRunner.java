/*
 * Copyright (C) 2014 AMIS research group, Faculty of Mathematics and Physics, Charles University in Prague, Czech Republic
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package cz.cuni.amis.pogamut.ut2004.agent.navigation;

import cz.cuni.amis.pogamut.base.communication.worldview.event.IWorldEventListener;
import cz.cuni.amis.pogamut.base.communication.worldview.object.IWorldObject;
import cz.cuni.amis.pogamut.base3d.worldview.object.ILocated;
import cz.cuni.amis.pogamut.base3d.worldview.object.Location;
import cz.cuni.amis.pogamut.unreal.communication.messages.UnrealId;
import cz.cuni.amis.pogamut.ut2004.agent.module.sensor.AgentInfo;
import cz.cuni.amis.pogamut.ut2004.agent.navigation.loquenavigator.KefikRunner;
import cz.cuni.amis.pogamut.ut2004.bot.command.AdvancedLocomotion;
import cz.cuni.amis.pogamut.ut2004.bot.impl.UT2004Bot;
import cz.cuni.amis.pogamut.ut2004.communication.messages.gbcommands.Move;
import cz.cuni.amis.pogamut.ut2004.communication.messages.gbinfomessages.NavPointNeighbourLink;
import cz.cuni.amis.pogamut.ut2004.communication.messages.gbinfomessages.Player;
import cz.cuni.amis.pogamut.ut2004.communication.messages.gbinfomessages.WallCollision;
import cz.cuni.amis.pogamut.ut2004.utils.LinkFlag;
import cz.cuni.amis.pogamut.ut2004.utils.UnrealUtils;
import cz.cuni.amis.utils.NullCheck;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Playing with and modifying {@link KefikRunner} to test path following
 * behaviour.
 *
 * We assume that we work with path generated by NavMesh path planner. It should
 * contain point on the nav mesh, which should be navigable by simple running,
 * and off-mesh connections, which we will handle as original runner.
 *
 *
 * @author Bogo
 */
public class NavMeshRunner implements IUT2004PathRunner {

    private UT2004Bot bot;
    private AgentInfo memory;
    private AdvancedLocomotion body;
    private Logger log;
    private IWorldEventListener<?> myCollisionsListener;

    // MAINTAINED CONTEXT
    /**
     * Number of steps we have taken.
     */
    private int runnerStep = 0;

    /**
     * Jumping sequence of a single-jumps.
     */
    private int jumpStep = 0;

    /**
     * Collision counter.
     */
    private int collisionNum = 0;

    /**
     * Collision location.
     */
    private Location collisionSpot = null;

    // COMPUTED CONTEXT OF THE runToLocation
    /**
     * Current distance to the target, recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private double distance;

    /**
     * Current 2D distance (only in x,y) to the target, recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private double distance2D;

    /**
     * Current Z distance to the target (positive => target is higher than us,
     * negative => target is lower than us), recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private double distanceZ;

    /**
     * Current velocity of the bot, recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private double velocity;

    /**
     * Current velocity in Z-coord (positive, we're going up / negative, we're
     * going down), recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private double velocityZ;

    /**
     * Whether the jump is required somewhere along the link, recalculated every
     * {@link KefikRunner#runToLocation(Location, Location, ILocated, NavPointNeighbourLink, boolean)}
     * invocation.
     */
    private boolean jumpRequired;

    /**
     * In case of fall ({@link KefikRunner#distanceZ} < 0), how far can we get
     * with normal fall.
     */
    private double fallDistance;

    // CONTEXT PASSED INTO runToLocation
    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private Location runningFrom;

    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private Location firstLocation;

    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private Location secondLocation;

    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private ILocated focus;

    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private NavPointNeighbourLink link;

    /**
     * Current context of the
     * {@link KefikRunner#runToLocation(Location, Location, Location, ILocated, NavPointNeighbourLink, boolean)}.
     */
    private boolean reachable;

    /**
     * Last received wall colliding event
     */
    protected WallCollision lastCollidingEvent = null;
    /**
     * If we have collided in last second we will signal it
     */
    private static final double WALL_COLLISION_THRESHOLD = 1;

    public void reset() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public boolean runToLocation(Location runningFrom, Location firstLocation, Location secondLocation, ILocated focus, NavPointNeighbourLink navPointsLink, boolean reachable) {
        // take another step
        ++runnerStep;

        // save context
        this.runningFrom = runningFrom;
        this.firstLocation = firstLocation;
        this.secondLocation = secondLocation;
        this.focus = focus;
        this.link = navPointsLink;
        this.reachable = reachable;

        // compute additional context
        distance = memory.getLocation().getDistance(firstLocation);
        distance2D = memory.getLocation().getDistance2D(firstLocation);
        distanceZ = firstLocation.getDistanceZ(memory.getLocation());
        if (distanceZ >= 0) {
            fallDistance = 0;
        } else {
            fallDistance = getFallDistance(distanceZ);
        }
        velocity = memory.getVelocity().size();
        velocityZ = memory.getVelocity().z;
        jumpRequired
                = !reachable
                || (link != null
                && (((link.getFlags() & LinkFlag.JUMP.get()) != 0)
                || (link.isForceDoubleJump())
                || (link.getNeededJump() != null)));
        
        
        logDebugData(firstLocation, secondLocation, focus, reachable);

        // DELIBERATION
        if (runnerStep <= 1) {
            debug("FIRST STEP - start running towards new location");
            move(firstLocation, secondLocation, focus);
        }

        // are we jumping already?
        if (jumpStep > 0) {
            debug("we're already jumping");
            return iterateJumpSequence();
        }

        // collision experienced?
        if (isColliding()) {
            debug("sensing collision");
            // try to resolve it
            return resolveCollision();
        } else {
            if (collisionSpot != null || collisionNum != 0) {
                debug("no collision, clearing collision data");
                collisionNum = 0;
                collisionSpot = null;
            }
        }

        if (velocity < 5 && runnerStep > 1) {
            debug("velocity is zero and we're in the middle of running");
            if (link != null && (link.getFromNavPoint().isLiftCenter() || link.getFromNavPoint().isLiftExit())) {
                if (link.getFromNavPoint().isLiftCenter()) {
                    debug("we're standing on the lift center, ok");
                } else {
                    debug("we're standing on the lift exit, ok");
                }
            } else {
                debug("and we're not standing on the lift center");
                return initJump(true);
            }
        }

        // check jump
        if (jumpRequired) {
            debug("jump is required");
            return resolveJump();
        }

        // just continue with ordinary run
        debug("keeping running to the target");
        move(firstLocation, secondLocation, focus);

        return true;
    }

    private void logDebugData(Location firstLocation, Location secondLocation, ILocated focus, boolean reachable) {
        // DEBUG LOG
        if (log != null && log.isLoggable(Level.FINER)) {
            debug("KefikRunner!");
            debug("running to    = " + firstLocation + " and than to " + secondLocation + " and focusing to " + focus);
            debug("bot position  = " + memory.getLocation());
            debug("distance      = " + distance);
            debug("distance2D    = " + distance2D);
            debug("distanceZ     = " + distanceZ);
            debug("fallDistance  = " + fallDistance);
            debug("velocity      = " + velocity);
            debug("velocityZ     = " + velocityZ);
            debug("jumpRequired  = " + jumpRequired
                    + (!reachable ? " NOT_REACHABLE" : "")
                    + (link == null
                            ? ""
                            : ((link.getFlags() & LinkFlag.JUMP.get()) != 0 ? " JUMP_FLAG" : "") + (link.isForceDoubleJump() ? " DOUBLE_JUMP_FORCED" : "") + (link.getNeededJump() != null ? " AT[" + link.getNeededJump() + "]" : ""))
            );
            debug("reachable     = " + reachable);
            if (link != null) {
                debug("link          = " + link);
            } else {
                debug("LINK NOT PRESENT");
            }
            debug("collisionNum  = " + collisionNum);
            debug("collisionSpot = " + collisionSpot);
            debug("jumpStep      = " + jumpStep);
            debug("runnerStep    = " + runnerStep);
        }
    }

    /**
     * Constructor.
     *
     * @param bot Agent's bot.
     * @param agentInfo
     * @param locomotion
     * @param log
     */
    public NavMeshRunner(UT2004Bot bot, AgentInfo agentInfo, AdvancedLocomotion locomotion, Logger log) {
        // setup reference to agent
        NullCheck.check(bot, "bot");
        this.bot = bot;
        NullCheck.check(agentInfo, "agentInfo");
        this.memory = agentInfo;
        NullCheck.check(locomotion, "locomotion");
        this.body = locomotion;

        //registering listener for wall collisions
        bot.getWorldView().addEventListener(WallCollision.class, myCollisionsListener);

        this.log = log;
        if (this.log == null) {
            this.log = bot.getLogger().getCategory(this.getClass().getSimpleName());
        }
    }

    /**
     * Return how far the normal falling will get us. (Using guessed consts...)
     *
     * @param distanceZ
     * @return
     */
    private double getFallDistance(double distanceZ) {
        distanceZ = Math.abs(distanceZ);
        if (distanceZ == 60) {
            return 160;
        }
        if (distanceZ < 60) {
            return 2.66667 * distanceZ;
        }
        return 1.3714 * distanceZ + 35.527;
    }

    private void debug(String message) {
        if (log.isLoggable(Level.FINER)) {
            log.log(Level.FINER, "Runner: {0}", message);
        }
    }
    
    private void move(ILocated firstLocation, ILocated secondLocation, ILocated focus) {
    	Move move = new Move();
    	if (firstLocation != null) {
    		move.setFirstLocation(firstLocation.getLocation());
    	}
    	if (secondLocation != null) {
    		move.setSecondLocation(secondLocation.getLocation());
    	}
    	
    	if (focus != null) {
    		if (focus instanceof Player) {
    			move.setFocusTarget((UnrealId)((IWorldObject)focus).getId());
    		} else {	
    			move.setFocusLocation(focus.getLocation());
    		}
    	}
    	
    	debug("MOVING: " + move);    	
    	bot.getAct().act(move);
    }

    private boolean resolveCollision() {
        // are we colliding at a new spot?
        if (
            // no collision yet
            (collisionSpot == null)
            // or the last collision is far away
            || (memory.getLocation().getDistance2D(collisionSpot) > 120)
        ) {
            // setup new collision spot info
        	if (log != null && log.isLoggable(Level.FINER)) log.finer("Runner.resolveCollision(): collision");
            collisionSpot = memory.getLocation();
            collisionNum = 1;
            // meanwhile: keep running to the location..
            move(firstLocation, secondLocation, focus);
            return true;
        }
        // so, we were already colliding here before..
        // try to solve the problem according to how long we're here..
        else { 
            return initJump(true);
        }
    }

    private boolean isColliding() {
        if (lastCollidingEvent == null) return false;
    	debug("isColliding():"+"(memory.getTime():" + memory.getTime() + " - (lastCollidingEvent.getSimTime() / 1000):" + (lastCollidingEvent.getSimTime() / 1000) +" <= WALL_COLLISION_THRESHOLD:" + WALL_COLLISION_THRESHOLD +  " )");
    	if (memory.getTime() - (lastCollidingEvent.getSimTime() / 1000) <= WALL_COLLISION_THRESHOLD ) {
    		debug("isColliding():return true;");
    		return true;
    	}
    	
    	return false;
    }
    
    private boolean resolveJump() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private boolean initJump(boolean forceJump) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private boolean iterateJumpSequence() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

}
